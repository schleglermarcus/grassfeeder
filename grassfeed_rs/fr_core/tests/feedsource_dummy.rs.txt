// use fr_core::db::feed_src_repo::FeedSourceEntry;
// use fr_core::db::feed_src_repo::IFeedSourceRepo;
// use fr_core::db::feed_src_repo::IconRepo;
use fr_core::db::tablehelper::GlueExecMemory;
use fr_core::db::tablehelper::GlueExecType;
use fr_core::db::tablehelper::ITableHelper;
use fr_core::db::tablehelper::TableHelper;
use std::cell::RefCell;
use std::sync::Arc;
use std::sync::RwLock;

// #[allow(unused_imports)]
use log::*;

// #[derive(Default)]
pub struct FeedSourceDummy {
    pub fs_list: RefCell<Vec<FeedSourceEntry>>,
    pub last_repo_id: RefCell<isize>,
    pub iconrepo: IconRepo,
}

impl FeedSourceDummy {
    ///  <0 : random
    #[allow(dead_code)]
    pub fn new(start_repo_id: isize) -> Self {
        let mut startv = start_repo_id;
        if start_repo_id < 0 {
            startv = (rand::random::<u8>() % 64) as isize;
        }

        let g_e_t: GlueExecType = Arc::new(RwLock::new(GlueExecMemory::new()));

        FeedSourceDummy {
            fs_list: RefCell::new(Vec::default()),
            last_repo_id: RefCell::new(startv as isize),
            iconrepo: IconRepo::new(g_e_t),
        }
    }

    fn get_next_repo_id(&self) -> isize {
        *(self.last_repo_id.borrow_mut()) += 1;
        self.last_repo_id.borrow().clone()
    }

    /// recursive
    pub fn dump_tree_rec(&self, lpath: &[u16], parent_repo_id: isize) {
        let entries = self.get_by_parent_repo_id(parent_repo_id as isize);

        entries.iter().enumerate().for_each(|(n, fse)| {
            let mut path: Vec<u16> = Vec::new();
            path.extend_from_slice(lpath);
            path.push(n as u16);
            let spaces = vec![32; path.len() * 2];
            let sp = std::str::from_utf8(&spaces).unwrap();
            trace!(" {:?}{}{} {}", path, sp, fse, fse.display_name);
            self.dump_tree_rec(&path, fse.repo_id);
        });
        /*
                for fse in entries {
                    let mut path: Vec<u16> = Vec::new();
                    path.extend_from_slice(lpath);
                    path.push(fse.folder_position as u16);
                    let spaces = vec![32; path.len() * 2];
                    let sp = std::str::from_utf8(&spaces).unwrap();
                    trace!(" {:?}{}{} {}", path, sp, fse, fse.display_name);
                    self.dump_tree_rec(&path, fse.repo_id);
                }
        */
    }
}

impl IFeedSourceRepo for FeedSourceDummy {
    fn helper(&self) -> &TableHelper<FeedSourceEntry> {
        unimplemented!(); // if this is needed for tests, tramsfer the method to IFeedSourceRepo
    }
    fn helper_mut(&mut self) -> &mut TableHelper<FeedSourceEntry> {
        unimplemented!();
    }
    fn iconrepo(&self) -> &IconRepo {
        unimplemented!();
    }

    fn iconrepo_exec(&self) -> GlueExecType {
        self.iconrepo.helper().get_glue_exec()
    }

    // fn debug_dump_tree(&self) {        self.dump_tree_rec(&[], 0);    }

    fn debug_dump_tree(&self) {
        if false {
            self.get_all_entries().iter().for_each(|fse| {
                trace!("DD: {}	{}", fse, fse.display_name);
            });
        } else {
            self.dump_tree_rec(&[], 0);
        }
    }

    /// sorts by folder_position
    fn get_by_parent_repo_id(&self, parent_repo_id: isize) -> Vec<FeedSourceEntry> {
        let mut r: Vec<FeedSourceEntry> = self
            .fs_list
            .borrow()
            .iter()
            .filter(|fs| fs.parent_repo_id == parent_repo_id)
            .map(|fs| fs.clone())
            .collect::<Vec<FeedSourceEntry>>();
        r.sort_by(|a, b| a.folder_position.cmp(&(*b).folder_position));
        r
    }

    fn update_folder_position(&self, src_id: isize, new_folder_pos: isize) {
        let mut upd_count = 0;
        self.fs_list
            .borrow_mut()
            .iter_mut()
            .filter(|fs| fs.repo_id == src_id)
            .take(1)
            .for_each(|fs| {
                fs.folder_position = new_folder_pos;
                upd_count += 1;
            });
        if upd_count == 0 {
            error!("update failed, repo_id {} not found. ", src_id);
        }
    }

    fn update_parent_and_folder_position(
        &self,
        src_id: isize,
        new_parent_id: isize,
        new_folder_pos: isize,
    ) {
        match self
            .fs_list
            .borrow_mut()
            .iter_mut()
            .filter(|fs| fs.repo_id == src_id)
            .next()
        {
            Some(mut fs) => {
                fs.parent_repo_id = new_parent_id;
                fs.folder_position = new_folder_pos;
                // debug!(                    "DU id:{} {}  => par:{} FP:{}",                    src_id, fs.display_name, new_parent_id, new_folder_pos               );
            }
            None => {
                error!("NOTFOUND: {} ", src_id);
            }
        }
    }

    fn get_by_index(&self, indexvalue: isize) -> Option<FeedSourceEntry> {
        self.fs_list
            .borrow()
            .iter()
            .filter(|fs| fs.repo_id == indexvalue)
            .map(|fs| fs.clone())
            .next()
    }

    fn get_all_entries(&self) -> Vec<FeedSourceEntry> {
        self.fs_list.borrow().clone()
    }

    fn store_entry(
        &self,
        entry: &FeedSourceEntry,
    ) -> Result<FeedSourceEntry, Box<dyn std::error::Error>> {
        self.fs_list.borrow_mut().push(entry.clone());
        Ok(entry.clone())
    }

    fn store_entries(
        &self,
        e_list: &Vec<FeedSourceEntry>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        for e in e_list {
            let mut fse = e.clone();
            fse.repo_id = self.get_next_repo_id();
            self.fs_list.borrow_mut().push(fse);
        }
        Ok(())
    }

    fn delete_by_index(&self, indexvalue: isize) {
        self.fs_list
            .borrow_mut()
            .retain(|fs| fs.repo_id != indexvalue);
    }

    fn update_expanded(&self, _src_ids: Vec<isize>, _new_expanded: bool) {
        unimplemented!();
    }
    /// get by parent_repo_id  and folder_position
    fn get_by_pri_fp(&self, _parent_repo_id: isize, _folder_pos: isize) -> Vec<FeedSourceEntry> {
        unimplemented!();
    }

    /// sorts by folder_position
    fn get_all_nonfolder(&self) -> Vec<FeedSourceEntry> {
        unimplemented!();
    }
    ///   store IconID into feed source
    fn update_icon(&self, _src_id: isize, _icon_id: usize, _timestamp_s: i64) {
        unimplemented!();
    }

    fn update_displayname(&self, _src_id: isize, _new_name: String) {
        unimplemented!()
    }

    fn update_url(&self, _src_id: isize, _new_url: String) {
        unimplemented!()
    }

    fn update_timestamps(&self, _src_id: isize, _updated_int: i64, _updated_ext: Option<i64>) {
        unimplemented!()
    }

    fn get_by_fetch_time(&self, _updated_time_s: i64) -> Vec<FeedSourceEntry> {
        return Vec::default();
    }

    fn update_last_selected(&self, _src_id: isize, _fc_id: isize) {
        unimplemented!()
    }
}
